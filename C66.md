# C66 Device API Documentation

## Overview

This document provides comprehensive documentation for the **DeviceAPI** library (version 20250209) used in handheld RFID/barcode devices. The library is provided as an Android Archive (AAR) and supports multiple hardware platforms including MTK and Qualcomm chipsets.

**Package**: `com.rscja.deviceapi`
**Min SDK**: Android 16
**Target SDK**: Android 30
**Architectures**: armeabi, armeabi-v7a, arm64-v8a

---

## Table of Contents

1. [UHF RFID Operations](#1-uhf-rfid-operations)
2. [Barcode Scanning](#2-barcode-scanning)
3. [Fingerprint Reader](#3-fingerprint-reader)
4. [Printer](#4-printer)
5. [Module Management](#5-module-management)
6. [LED Control](#6-led-control)
7. [PSAM & Card Operations](#7-psam--card-operations)
8. [Low-Frequency RFID](#8-low-frequency-rfid)
9. [Utilities & Helpers](#9-utilities--helpers)
10. [Exception Handling](#10-exception-handling)
11. [Complete Example](#11-complete-example)

---

## 1. UHF RFID Operations

### 1.1 Main Classes

#### RFIDWithUHFUART
Primary class for UART-based UHF RFID operations.

```kotlin
import com.rscja.deviceapi.RFIDWithUHFUART
import com.rscja.deviceapi.entity.UHFTAGInfo
import com.rscja.deviceapi.interfaces.IUHF
```

#### Other UHF Implementations

- `RFIDWithUHFA4` - UHF A4 variant (basic)
- `RFIDWithUHFA4Uart` - UHF A4 with UART connection
- `RFIDWithUHFA4NetWork` - UHF A4 with Network connection
- `RFIDWithUHFA4RS232` - UHF A4 with RS232 connection
- `RFIDWithUHFA8` - UHF A8 variant (advanced)
- `RFIDWithUHFA8Uart` - UHF A8 with UART connection
- `RFIDWithUHFA8NetWork` - UHF A8 with Network connection
- `RFIDWithUHFA8RS232` - UHF A8 with RS232 connection
- `RFIDWithUHFUSB` - USB-based UHF reader
- `RFIDWithUHFBLE` - Bluetooth LE based UHF reader
- `RFIDWithUHFUrxNetwork` - URx Network variant
- `RFIDWithUHFUrxUart` - URx UART variant

### 1.2 Initialization & Connection

```kotlin
// Get singleton instance
val uhfReader = RFIDWithUHFUART.getInstance()

// Initialize the reader
val success: Boolean = uhfReader.init(context)

// Get version information
val version: String? = uhfReader.version

// Free resources (cleanup)
uhfReader.free()
```

### 1.3 Tag Inventory

#### Start/Stop Inventory

```kotlin
// Start continuous inventory
val started: Boolean = uhfReader.startInventoryTag()

// Read tags from buffer
val tagInfo: UHFTAGInfo? = uhfReader.readTagFromBuffer()

// Stop inventory
val stopped: Boolean = uhfReader.stopInventory()
```

#### Single Tag Inventory

```kotlin
// Inventory a single tag
val tagInfo: UHFTAGInfo? = uhfReader.inventorySingleTag()
```

### 1.4 UHFTAGInfo Entity

```kotlin
data class UHFTAGInfo(
    val epc: String,        // Electronic Product Code
    val tid: String?,       // Tag ID
    val rssi: Int?,         // Signal strength
    val count: Int?,        // Read count
    val user: String?,      // User data
    val antenna: Int?       // Antenna number
)
```

### 1.5 Memory Bank Operations

#### Bank Constants

```kotlin
IUHF.Bank_RESERVED  // Reserved memory (access/kill passwords)
IUHF.Bank_EPC       // EPC memory
IUHF.Bank_TID       // TID memory (read-only)
IUHF.Bank_USER      // User memory
```

#### Read Data

```kotlin
/**
 * Read data from tag memory
 * @param epc Tag EPC
 * @param bank Memory bank (Bank_USER, Bank_EPC, Bank_TID, Bank_RESERVED)
 * @param offset Starting address (word offset)
 * @param length Number of words to read
 * @return Hex string of data, or null if failed
 */
val data: String? = uhfReader.readData(
    epc = "E28068940000501234567890",
    bank = IUHF.Bank_USER,
    offset = 0,
    length = 4
)
```

#### Write Data

```kotlin
/**
 * Write data to tag memory
 * @param epc Tag EPC
 * @param bank Memory bank
 * @param offset Starting address (word offset)
 * @param length Number of words to write
 * @param data Hex string data to write
 * @return true if successful
 */
val success: Boolean = uhfReader.writeData(
    epc = "E28068940000501234567890",
    bank = IUHF.Bank_USER,
    offset = 0,
    length = 4,
    data = "12345678"
)
```

### 1.6 Tag Lock Operations

```kotlin
/**
 * Lock tag memory areas
 * @param epc Tag EPC
 * @param accessPassword Access password (8 hex chars)
 * @param bank Memory bank to lock
 * @param lockType Lock type (0=unlock, 1=lock, 2=permanent lock)
 * @return true if successful
 */
val locked: Boolean = uhfReader.lockMem(
    epc = "E28068940000501234567890",
    accessPassword = "00000000",
    bank = IUHF.Bank_USER,
    lockType = 1
)
```

### 1.7 Kill Tag

```kotlin
/**
 * Kill tag (permanently disable)
 * @param epc Tag EPC
 * @param killPassword Kill password (8 hex chars)
 * @return true if successful
 */
val killed: Boolean = uhfReader.killTag(
    epc = "E28068940000501234567890",
    killPassword = "00000000"
)
```

### 1.8 Power Management

```kotlin
// Set read power (0-30 dBm typically)
val success: Boolean = uhfReader.setPower(power = 26)

// Get current power setting
val power: Int = uhfReader.power

// Set antenna power individually
uhfReader.setANTPower(antenna = 1, power = 26)
```

### 1.9 Antenna Configuration

```kotlin
// Set active antenna (1-4 or 1-8 depending on hardware)
uhfReader.setANT(antenna = 1)

// Get antenna state
val state: Int = uhfReader.aNTState

// Check antenna connection status
val connected: Boolean = uhfReader.aNTConnectState
```

### 1.10 Filter Settings

```kotlin
/**
 * Set EPC filter for selective reading
 * @param bank Memory bank
 * @param offset Bit offset
 * @param length Data length
 * @param data Filter data (hex string)
 * @return true if successful
 */
val filtered: Boolean = uhfReader.setFilter(
    bank = IUHF.Bank_EPC,
    offset = 32,
    length = 96,
    data = "E2806894"
)
```

### 1.11 Frequency & Region

```kotlin
// Set frequency (region-dependent)
uhfReader.setFrequency(frequency = 920.625)

// Set region (0=China, 1=US, 2=EU, 3=Korea, etc.)
uhfReader.setRegion(region = 1)

// Get current region
val region: Int = uhfReader.region
```

### 1.12 Temperature Tag Support

```kotlin
/**
 * Read temperature from temperature-sensing tags
 * @param epc Tag EPC
 * @return Temperature value or null
 */
val temperature: Double? = uhfReader.readTagTemp(epc)

/**
 * Read multiple temperature tags
 * @return List of temperature readings
 */
val temps: List<TempReading>? = uhfReader.readMultiTemp()
```

### 1.13 Bluetooth UHF Methods

For BLE-based UHF readers (`RFIDWithUHFBLE`):

```kotlin
// Start BT inventory
uhfReader.uhfBTStartInventory()

// Get tag from BT buffer
val tag: UHFTAGInfo? = uhfReader.uhfBTGetTag()

// Stop BT inventory
uhfReader.uhfBTStopInventory()

// BT read/write
val data: String? = uhfReader.uhfBTReadData(epc, bank, offset, length)
val success: Boolean = uhfReader.uhfBTWriteData(epc, bank, offset, length, data)
```

---

## 2. Barcode Scanning

### 2.1 Main Classes

```kotlin
import com.rscja.deviceapi.Barcode1D
import com.rscja.deviceapi.Barcode2D
import com.rscja.deviceapi.entity.BarcodeEntity
import com.rscja.deviceapi.entity.BarcodeResult
```

### 2.2 1D Barcode Scanner

```kotlin
// Get instance
val barcode1D = Barcode1D.getInstance()

// Open scanner
val opened: Boolean = barcode1D.open(context)

// Start scanning
val result: BarcodeResult? = barcode1D.scan()

// Set timeout (milliseconds)
barcode1D.setTimeOut(timeout = 5000)

// Stop scanning
barcode1D.stopScan()

// Close scanner
barcode1D.close()
```

### 2.3 2D Barcode Scanner

```kotlin
// Get instance
val barcode2D = Barcode2D.getInstance()

// Open scanner
val opened: Boolean = barcode2D.open(context)

// Start scanning
val result: BarcodeResult? = barcode2D.scan()

// Stop scanning
barcode2D.stopScan()

// Close scanner
barcode2D.close()
```

### 2.4 BarcodeResult Entity

```kotlin
data class BarcodeResult(
    val barcode: String,        // Barcode data
    val barcodeType: String,    // Type (EAN13, CODE128, QR, etc.)
    val length: Int             // Data length
)
```

### 2.5 Barcode Utilities

```kotlin
import com.rscja.deviceapi.BarcodeSymbolUtility

// Convert barcode type to string
val typeName: String = BarcodeSymbolUtility.getTypeName(typeCode)

// Check if type is valid
val valid: Boolean = BarcodeSymbolUtility.isValidType(typeCode)
```

---

## 3. Fingerprint Reader

### 3.1 Main Classes

- `Fingerprint` - Generic fingerprint scanner
- `FingerprintWithFIPS` - FIPS-compliant fingerprint reader
- `FingerprintWithMorpho` - Morpho fingerprint scanner
- `FingerprintWithTLK1NC` - TLK1NC variant
- `FingerprintWithZAZ` - ZAZ variant
- `FingerprintSM206B` - SM206B variant
- `UsbFingerprint` - USB fingerprint reader

### 3.2 FIPS Fingerprint Scanner

```kotlin
import com.rscja.deviceapi.FingerprintWithFIPS
import com.rscja.deviceapi.interfaces.IFingerprintWithFIPS

// Get instance
val fingerprint = FingerprintWithFIPS.getInstance()

// Initialize
val initialized: Boolean = fingerprint.init(context)

// Enroll fingerprint
fingerprint.enroll(
    fingerId = 1,
    callback = object : FingerprintWithFIPS.EnrollCallBack {
        override fun onEnrollProgress(progress: Int) {
            // Progress: 0-100
        }

        override fun onEnrollSuccess(template: ByteArray) {
            // Enrollment complete
        }

        override fun onEnrollFailed(error: String) {
            // Enrollment failed
        }
    }
)

// Verify fingerprint
val verified: Boolean = fingerprint.verify(fingerId = 1)

// Identify fingerprint (1:N matching)
val matchedId: Int = fingerprint.identify()

// Delete fingerprint
val deleted: Boolean = fingerprint.delete(fingerId = 1)

// Clear all fingerprints
val cleared: Boolean = fingerprint.clearAll()

// Get template count
val count: Int = fingerprint.templateCount

// Free resources
fingerprint.free()
```

### 3.3 Morpho Fingerprint Scanner

```kotlin
import com.rscja.deviceapi.FingerprintWithMorpho

val fingerprint = FingerprintWithMorpho.getInstance()

// Similar API to FIPS variant
fingerprint.init(context)
fingerprint.enroll(fingerId, callback)
fingerprint.verify(fingerId)
fingerprint.identify()
```

---

## 4. Printer

### 4.1 Main Class

```kotlin
import com.rscja.deviceapi.Printer
import com.rscja.deviceapi.Printer.BarcodeType
import com.rscja.deviceapi.Printer.PrinterStatus
```

### 4.2 Printer Operations

```kotlin
// Get instance
val printer = Printer.getInstance()

// Initialize
val initialized: Boolean = printer.init(context)

// Print text
val printed: Boolean = printer.printText(text = "Hello World", fontSize = 24)

// Print barcode
val printed: Boolean = printer.printBarcode(
    data = "1234567890",
    barcodeType = BarcodeType.CODE128,
    width = 2,
    height = 50
)

// Print QR code
val printed: Boolean = printer.printQRCode(
    data = "https://example.com",
    size = 5
)

// Feed paper
printer.feedPaper(lines = 3)

// Get printer status
val status: PrinterStatus = printer.status

// Free resources
printer.free()
```

### 4.3 Printer Status

```kotlin
enum class PrinterStatus {
    READY,
    BUSY,
    OUT_OF_PAPER,
    LOW_PAPER,
    OVERHEAT,
    ERROR
}
```

---

## 5. Module Management

### 5.1 Module Class

```kotlin
import com.rscja.deviceapi.Module

// Initialize module
val module = Module()
val initialized: Boolean = module.init(context)

// Power control
module.powerOn()
module.powerOff()

// Send data
val sent: Boolean = module.send(data: ByteArray)

// Receive data
val data: ByteArray? = module.receive(timeout: Int)

// Send and receive
val response: ByteArray? = module.sendAndReceive(
    data: ByteArray,
    timeout: Int
)

// Free resources
module.free()
```

---

## 6. LED Control

### 6.1 LED Light Class

```kotlin
import com.rscja.deviceapi.LedLight
import com.rscja.deviceapi.ScanerLedLight

// Get instance
val ledLight = LedLight.getInstance()

// Turn on LED
ledLight.turnOn(ledId = 1)

// Turn off LED
ledLight.turnOff(ledId = 1)

// Toggle LED
ledLight.toggle(ledId = 1)

// Set brightness (0-100)
ledLight.setBrightness(ledId = 1, brightness = 50)
```

### 6.2 Scanner LED

```kotlin
val scanLed = ScanerLedLight.getInstance()

// Control scanner LED
scanLed.scanLedOn()
scanLed.scanLedOff()
```

---

## 7. PSAM & Card Operations

### 7.1 PSAM Class

```kotlin
import com.rscja.deviceapi.PSAM

// Get instance
val psam = PSAM.getInstance()

// Initialize
val initialized: Boolean = psam.init(context)

// Card operations
val balance: Int = psam.cardBalance()
val consumed: Boolean = psam.cardConsume(amount = 100)
val confirmed: Boolean = psam.cardConsumeConfirm()

// Update PSAM
val updated: Boolean = psam.update(data: ByteArray)

// Free resources
psam.free()
```

### 7.2 Card with BYL

```kotlin
import com.rscja.deviceapi.CardWithBYL

val card = CardWithBYL.getInstance()
card.init(context)
// Card operations
```

---

## 8. Low-Frequency RFID

### 8.1 LF RFID Class

```kotlin
import com.rscja.deviceapi.RFIDWithLF

// Get instance
val lfReader = RFIDWithLF.getInstance()

// Initialize
val initialized: Boolean = lfReader.init(context)

// Read EM125K card
val cardData: String? = lfReader.readEM125K()

// Read EM4305 card
val data: String? = lfReader.read4305()

// Write EM4305
val written: Boolean = lfReader.write4305(data: String)

// Read Hitag card
val hitagData: String? = lfReader.readHitag()

// Free resources
lfReader.free()
```

---

## 9. Utilities & Helpers

### 9.1 String Utility

```kotlin
import com.rscja.utility.StringUtility

// Hex conversion
val hexString: String = StringUtility.toHexString(byteArray)
val byteArray: ByteArray = StringUtility.hexToBytes(hexString)

// String utilities
val trimmed: String = StringUtility.trimStart(string, char)
val padded: String = StringUtility.padLeft(string, length, char)
```

### 9.2 Battery Utility

```kotlin
import com.rscja.deviceapi.entity.BatteryEntity

// Battery information
data class BatteryEntity(
    val level: Int,         // Battery level (0-100)
    val voltage: Float,     // Voltage
    val temperature: Float, // Temperature
    val status: String      // Status (charging, discharging, etc.)
)
```

### 9.3 Version Info

```kotlin
import com.rscja.deviceapi.VersionInfo

// Get device version information
val versionInfo = VersionInfo()
val hardwareVersion: String = versionInfo.hardwareVersion
val softwareVersion: String = versionInfo.softwareVersion
val apiVersion: String = versionInfo.apiVersion
```

---

## 10. Exception Handling

### 10.1 Exception Classes

```kotlin
import com.rscja.deviceapi.exception.*

try {
    // RFID operations
} catch (e: RFIDNotFoundException) {
    // Tag not found
} catch (e: RFIDReadFailureException) {
    // Read failure
} catch (e: RFIDArgumentException) {
    // Invalid argument
} catch (e: RFIDVerificationException) {
    // Verification failed
} catch (e: DeviceNotConnectException) {
    // Device not connected
} catch (e: LowBatteryException) {
    // Low battery
} catch (e: ConfigurationException) {
    // Configuration error
}
```

### 10.2 All Exception Types

- `ConfigurationException` - Configuration error
- `DeviceNotConnectException` - Device not connected
- `FingerprintAlreadyEnrolledException` - Fingerprint already enrolled
- `FingerprintInvalidIDException` - Invalid fingerprint ID
- `LowBatteryException` - Battery too low for operation
- `PrinterBarcodeInvalidException` - Invalid barcode for printing
- `PrinterLowPager` - Printer low on paper
- `PSAMException` - PSAM operation error
- `RFIDArgumentException` - Invalid RFID argument
- `RFIDNotFoundException` - RFID tag not found
- `RFIDReadFailureException` - RFID read failure
- `RFIDVerificationException` - RFID verification failed

---

## 11. Complete Example

### 11.1 UHF Manager Implementation

```kotlin
package com.example.uhf

import android.content.Context
import android.util.Log
import com.rscja.deviceapi.RFIDWithUHFUART
import com.rscja.deviceapi.entity.UHFTAGInfo
import com.rscja.deviceapi.interfaces.IUHF
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.withContext

class UHFManager private constructor() {
    private var uhfReader: RFIDWithUHFUART? = null
    private var isInitialized = false
    private var isScanning = false

    private val _tags = MutableStateFlow<List<TagInfo>>(emptyList())
    val tags: StateFlow<List<TagInfo>> = _tags

    private val _status = MutableStateFlow<String>("Not initialized")
    val status: StateFlow<String> = _status

    companion object {
        private const val TAG = "UHFManager"

        @Volatile
        private var instance: UHFManager? = null

        fun getInstance(): UHFManager {
            return instance ?: synchronized(this) {
                instance ?: UHFManager().also { instance = it }
            }
        }
    }

    suspend fun initialize(context: Context): Result<String> = withContext(Dispatchers.IO) {
        try {
            if (isInitialized) {
                return@withContext Result.success("Already initialized")
            }

            _status.value = "Initializing..."
            uhfReader = RFIDWithUHFUART.getInstance()

            val initResult = uhfReader?.init(context) ?: false
            if (initResult) {
                isInitialized = true
                val version = uhfReader?.version ?: "Unknown"
                _status.value = "Ready - Version: $version"
                Result.success(version)
            } else {
                _status.value = "Initialization failed"
                Result.failure(Exception("Failed to initialize"))
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing", e)
            _status.value = "Error: ${e.message}"
            Result.failure(e)
        }
    }

    suspend fun startInventory(): Result<String> = withContext(Dispatchers.IO) {
        try {
            if (!isInitialized) {
                return@withContext Result.failure(Exception("Not initialized"))
            }

            _tags.value = emptyList()
            val result = uhfReader?.startInventoryTag() ?: false

            if (result) {
                isScanning = true
                _status.value = "Scanning..."
                readTagsLoop()
                Result.success("Started")
            } else {
                Result.failure(Exception("Failed to start"))
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error starting inventory", e)
            Result.failure(e)
        }
    }

    private suspend fun readTagsLoop() = withContext(Dispatchers.IO) {
        val seenTags = mutableMapOf<String, TagInfo>()

        while (isScanning) {
            try {
                val tagInfo: UHFTAGInfo? = uhfReader?.readTagFromBuffer()

                if (tagInfo != null && !tagInfo.epc.isNullOrEmpty()) {
                    val tag = TagInfo(
                        epc = tagInfo.epc,
                        tid = tagInfo.tid ?: "",
                        rssi = tagInfo.rssi?.toString() ?: "0",
                        count = (seenTags[tagInfo.epc]?.count ?: 0) + 1
                    )

                    seenTags[tagInfo.epc] = tag
                    _tags.value = seenTags.values.sortedByDescending { it.count }
                    _status.value = "Found ${seenTags.size} tags"
                }

                delay(50)
            } catch (e: Exception) {
                Log.e(TAG, "Error reading tag", e)
            }
        }
    }

    suspend fun stopInventory(): Result<String> = withContext(Dispatchers.IO) {
        try {
            isScanning = false
            val result = uhfReader?.stopInventory() ?: false
            _status.value = "Stopped - ${_tags.value.size} tags"
            Result.success("Stopped")
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun readTagData(
        epc: String,
        bank: Int = IUHF.Bank_USER,
        offset: Int = 0,
        length: Int = 4
    ): Result<String> = withContext(Dispatchers.IO) {
        try {
            val data = uhfReader?.readData(epc, bank, offset, length)
            if (!data.isNullOrEmpty()) {
                Result.success(data)
            } else {
                Result.failure(Exception("Read failed"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun writeTagData(
        epc: String,
        bank: Int = IUHF.Bank_USER,
        offset: Int = 0,
        length: Int = 4,
        data: String
    ): Result<String> = withContext(Dispatchers.IO) {
        try {
            val result = uhfReader?.writeData(epc, bank, offset, length, data) ?: false
            if (result) {
                Result.success("Written")
            } else {
                Result.failure(Exception("Write failed"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    fun clearTags() {
        _tags.value = emptyList()
        _status.value = if (isInitialized) "Ready" else "Not initialized"
    }

    suspend fun disconnect(): Result<String> = withContext(Dispatchers.IO) {
        try {
            if (isScanning) stopInventory()
            uhfReader?.free()
            isInitialized = false
            _status.value = "Disconnected"
            _tags.value = emptyList()
            Result.success("Disconnected")
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    data class TagInfo(
        val epc: String,
        val tid: String = "",
        val rssi: String = "0",
        val count: Int = 1
    )
}
```

### 11.2 Usage in Activity/Fragment

```kotlin
class MainActivity : AppCompatActivity() {
    private val uhfManager = UHFManager.getInstance()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Initialize
        lifecycleScope.launch {
            uhfManager.initialize(this@MainActivity).onSuccess {
                Log.d("UHF", "Initialized: $it")
            }.onFailure {
                Log.e("UHF", "Failed", it)
            }
        }

        // Observe tags
        lifecycleScope.launch {
            uhfManager.tags.collect { tags ->
                // Update UI with tags
                updateTagList(tags)
            }
        }

        // Start scanning
        btnScan.setOnClickListener {
            lifecycleScope.launch {
                uhfManager.startInventory()
            }
        }

        // Stop scanning
        btnStop.setOnClickListener {
            lifecycleScope.launch {
                uhfManager.stopInventory()
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        lifecycleScope.launch {
            uhfManager.disconnect()
        }
    }
}
```

---

## Appendix A: Memory Bank Layout

### EPC Gen2 Tag Memory Structure

```
┌─────────────────┬────────┬─────────────────────────┐
│ Memory Bank     │ Bank # │ Description             │
├─────────────────┼────────┼─────────────────────────┤
│ RESERVED        │ 0      │ Kill/Access Passwords   │
│ EPC             │ 1      │ EPC Data, PC, CRC       │
│ TID             │ 2      │ Tag ID (read-only)      │
│ USER            │ 3      │ User data (read/write)  │
└─────────────────┴────────┴─────────────────────────┘
```

### Typical Memory Sizes

- **RESERVED**: 64 bits (4 words) - 32-bit kill password + 32-bit access password
- **EPC**: 96-496 bits - Varies by tag type
- **TID**: 32-256 bits - Factory programmed, read-only
- **USER**: 0-8192 bits - Varies by tag model

---

## Appendix B: Error Codes

### Common Error Codes

| Code | Description |
|------|-------------|
| 0x00 | Success |
| 0x01 | Tag not found |
| 0x02 | CRC error |
| 0x03 | Invalid parameter |
| 0x04 | Memory overrun |
| 0x05 | Memory locked |
| 0x0B | Insufficient power |
| 0x0F | Non-specific error |

---

## Appendix C: Frequency Bands by Region

| Region | Frequency Range | Channel Count |
|--------|----------------|---------------|
| US (FCC) | 902-928 MHz | 50 channels |
| EU (ETSI) | 865-868 MHz | 4 channels |
| China | 920-925 MHz | 16 channels |
| Korea | 917-923.5 MHz | 6 channels |
| Japan | 916.8-920.4 MHz | 4 channels |

---

## Appendix D: Support & Resources

### Library Information

- **Version**: 20250209
- **Release Date**: February 9, 2025
- **Package**: com.rscja.deviceapi
- **File**: DeviceAPI_ver20250209_release.aar

### Native Libraries

- `libDeviceAPIQ.so` - Qualcomm platform
- `libDeviceAPIM.so` - MTK platform
- `libIDFingerprintAlg.so` - Fingerprint algorithms

### Supported Architectures

- armeabi (32-bit ARM)
- armeabi-v7a (32-bit ARMv7)
- arm64-v8a (64-bit ARMv8)

---

## License

Refer to the device manufacturer's documentation for licensing information.

---

**Last Updated**: February 10, 2026
**Document Version**: 1.0
